# Homeworks 
## [Summary of Homework 1](https://github.com/MarkShinozaki/CPTS322-SoftwareEngineeringPrinciples1/tree/Homeworks/Homework1)

#### 1. Umbrella Activities Across the Software Process:
- Umbrella activities are applied throughout the software process, but their focus varies. For example, risk management is more critical during design, while documentation is emphasized during testing. The level of emphasis depends on the project phase and methodology.

#### 2. Applicability of Framework Activities to All Projects:
- Framework activities like communication and planning are applicable to all projects, but the specific tasks vary based on the project's size and complexity. Smaller projects may require less extensive planning compared to larger ones.

#### 3. Difference Between Software and Other Engineering Products:
- Software is intangible, created from ideas rather than physical materials, making it more flexible but also more uncertain and risky compared to tangible engineering products like hardware.

#### 4. Documentation of Problems and Search Queries:
- Various search queries were used to resolve issues related to the assignment, with most yielding helpful results. The process was documented systematically.


--- 

## [Summary of Homework 2](https://github.com/MarkShinozaki/CPTS322-SoftwareEngineeringPrinciples1/tree/Homeworks/Homework2)

#### 1. Best Process Model for Different Projects:

- **Anti-lock Braking System**: Waterfall model is ideal due to its sequential, structured approach, ensuring thorough testing and validation at each stage.

- **Virtual Reality System for Software Maintenance**: Agile model is best, emphasizing flexibility, collaboration, and frequent iterations suitable for emerging technologies like VR.

- **University Accounting System**: Spiral model is chosen for its combination of risk management and flexibility, handling the systemâ€™s complexity and importance.

- **Interactive Travel Planning System**: Agile model is preferred for managing ever-changing user requirements, allowing frequent feedback and updates.

#### 2. Examples Suitable for the Waterfall Model:

- **Banking System**: A step-by-step approach minimizes errors and ensures the system meets financial requirements.

- **Medical Device Software**: The linear, thorough process meets regulatory and safety standards.

- **Bridge Design Software**: A sequential process ensures data accuracy and effectiveness in the final design.

#### 3. Examples Suitable for the Prototyping Model:

- **Mobile App Development**: Iterative design focuses on user feedback for usability and functionality.

- **E-commerce Website**: Rapid feedback enables testing of different designs and features.

- **Video Game Development**: Allows for experimentation with game elements and refinement based on beta testing feedback.

#### 4. Differences and Similarities Between Spiral and Incremental Models:

- **Difference**: Spiral focuses on risk management, while incremental focuses on delivering products incrementally.

- **Similarity**: Both models are iterative, flexible, and allow for changes during the development process, improving the final product over time.

--- 

## [Summary of Homework 3](https://github.com/MarkShinozaki/CPTS322-SoftwareEngineeringPrinciples1/tree/Homeworks/Homework3)

#### 1. Use-Case Diagram for the Facebook App:

- The use-case diagram includes key user actions such as login, sending friend requests, posting information, and managing accounts. It also covers system admin actions like auditing accounts, pushing updates, and suspending users. The relationships between use cases and actors are clearly represented using standard UML notations like include and extend.

#### 2. Activity Diagram for a Use Case:

- The activity diagram models the login process, detailing steps from entering credentials to verifying username and password, with decision points for handling incorrect entries. The diagram effectively captures the sequence of actions and possible outcomes.

#### 3. Swimlane Diagram for the Same Use Case:

- The swimlane diagram aligns with the activity diagram, showing the interactions between the user and the system during the login process. It separates responsibilities, with lanes for the user, server, and admin, clearly depicting the flow of actions across these entities.

---

## [Summary of Homework 4](https://github.com/MarkShinozaki/CPTS322-SoftwareEngineeringPrinciples1/tree/Homeworks/Homework4)

#### 1. Difference and Similarity Between Sequence Diagram and Statechart Diagram:

- Sequence diagrams show the execution of a particular use case and the interaction between objects, emphasizing temporal order. Statechart diagrams focus on the states of an object or system and transitions between them, without temporal details. Both use UML notation to model system behavior.

#### 2. UML State Diagram for Smartphone Dialer App:

- A UML state diagram was created to model the behavior of a smartphone dialer app, showing various states like "Idle," "Dialing," "In Call," and "Call Ended," along with transitions triggered by user actions and system events.

#### 3. UML Sequence Diagram for Online Shopping System:

- The UML sequence diagram models the process of placing an order in an online shopping system, involving interactions between the buyer, item, seller, and system services to complete the transaction.

#### 4. Documentation of Problems and Search Queries:

- A table documenting the issues encountered, sources consulted, and the relevance and credibility of those sources was completed. The table includes six sources, with assessments of their effectiveness in resolving problems related to UML diagrams and software engineering concepts.

---

## [Summary of Homework 5](https://github.com/MarkShinozaki/CPTS322-SoftwareEngineeringPrinciples1/tree/Homeworks/Homework5)

#### 1. Architectural Styles and Examples:

- **Data-Centered**: A database management system is ideal, as the architecture revolves around data storage, manipulation, and retrieval.

- **Data-Flow**: A financial trading system fits well, with continuous data flow and real-time processing for decision-making.

- **Call-Return**: A web application exemplifies this, with functions called hierarchically to achieve system functionality.

- **Layered**: An operating system suits the layered architecture, with layers built on top of each other, each providing specific services.

#### 2. Cohesion and Coupling in Software Design:

- **Cohesion**: Refers to how closely related the functionality of components within a module is. High cohesion is better as it ensures modules focus on a single task, enhancing flexibility and maintainability.
  
- **Coupling**: Refers to the level of interdependence between modules. Low coupling is preferable because it promotes independence between components, making the system more scalable and easier to maintain.

#### 3. Component Diagrams from DFD:

- Derived component diagrams based on a given data flow diagram (DFD) for the ACE store management software. The diagrams represent the architecture design, focusing on tasks like preprocessing queries, generating item descriptions, and finalizing reports, using standard UML notations.













